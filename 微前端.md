### 基本概念
微前端是将微服务的概念运用到前端技术后到相关实践，使得一个项目能够被多个前端团队独立开发和独立部署。(项目级别对模块化)

### 微前端需要解决的问题
1. 微应用的注册、异步加载和生命周期管理;
2. 微应用之间、主从之间的消息机制;
3. 微应用之间的安全隔离措施;
4. 微应用的框架无关、版本无关; 微应用之间、主从之间的公共依赖的库、业务逻辑(utils)以及版本怎么管理; 
5. 微应用独立调试、和主应用联调的方式，快速定位报错(发射问题); 
6. 微应用的发布流程;
7. 微应用打包优化问题;
8. 微应用专有云场景的出包方案;

### 工作原理
![](./imgs/weiqianduan.png)
### 实现思路
#### iframe
优点：改造成本低，可以快速上线，都是沙箱环境
缺点：
    1. iframe嵌入的可视区大小不容易控制，存在一定的局限性
    2. bfcache： url的记录完全无效，页面刷新不能被记录，刷新会回到首页。iframe功能间跳转也失效。
    3. iframe样式兼容性存在问题。
    4. 性能开销： iframe阻塞onload事件，多嵌套页面容易奔溃。

#### webComponent
缺点：
    兼容性问题

### 多应用微前端框架
#### yog2
基于fis和express的开发的应用架构
适用于非静态项目(node) - 都是多页应用
yog提供一个壳做容器做应用的注册，管理和加载。通过文件夹隔离（路由），如果需要内嵌，只能用iframe

通信： localstorage 和 listener.js
listener的原理：
    事件分发的原理
    listener.on('xxx', callback)
    listener.trigger("xxx, params)
之后将listener写到localstorage里




### spa微前端框架

核心是前端独立发包

流行库：
    Bifrost，qiankun， single-spa，基于serverless的服务


实现方式一： 
    package： 在团队较小，项目不大的情况下，可以使用package的形式独立发包，主项目通过npm update的形式去更新，缺点是维护成本高，更新包需要编译

实现方式二：
    子项目独立部署后 - http:XXXX/index.js
    主项目异步加载：  import('http:XXXX/index.js').then()

    存在问题：
        子项目index.vue -> index.js,使用webpack打包后 index.js的chunk(md5)是webpack内部维护的,也就是由子项目的main.js去维护  index.xx1222.js

        在主项目中引用的index.xx1222.js时，由于主项目自身有自己的包管理机制 main.js，由于有依赖关系会造成混乱。

    解决方案：
        system.js,可以摆脱主项目对模块对依赖，使得每个js都是独立的js
    
    通信机制：
        listener

    好处： 提供了样式隔离
    
    重点解决问题：
        1. 只能支持异步组件，如果需要支持同步组件，需要一个js并发执行器
        2. 路由发现和路由注册，所有项目维护一个router.json文件，带上版本的md5戳
        3. webpack对本身模块化对机制，影响甚大
        4. 主站需要引入不同对库，<script src="react.min.js"></script>,不同项目维护不同对生命周期，混合react，vue组件创建之前，组件渲染之后，也就是需要mixin各种生命周期


    比较好的解决方案是利用webpack5，webpack5 更新了模块化打包机制，类似于qiankun这类库也是对webpack5对封装


