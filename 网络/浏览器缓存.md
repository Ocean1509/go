### 对于浏览器缓存的总结
过程: 浏览器第一次访问会向服务器发起资源的请求，请求拿到响应，并根据响应头字段进行缓存。第二次请求资源时，由于浏览器存在缓存会先判断强缓存是否过期，强缓存的字段有两个，一个是http1.0的expries，一个是http1.1的cache-control，前一个是时间戳，由于时间戳受本地系统时间影响，所以expries判断缓存过期并不可靠，所有有了cache-control字段。当判断强缓存没有过期时，直接用缓存的数据而不再去服务器请求。强缓存失效时，会进行协商缓存，浏览器发送请求到服务器，请求头会有if-modify-since/if-none-match字段，浏览器会根据这两个字段判断缓存是否过期，如果缓存没有过期，服务端返回的响应只有响应行和响应头，没有响应的实体内容，状态码为304，客户端通过响应头的last-modify和etag字段，判断缓存没有过期，则直接使用缓存数据。如果服务端判断已经过期，则会返回完整的响应数据，状态码为200


### cache-control值
Cache-Control: public可以被所有用户缓存，包括终端和CDN等中间代理服务器
Cache-Control: private只能被终端浏览器缓存，不允许中继缓存服务器进行缓存
Cache-Control: no-cache,先缓存本地，但是在命中缓存之后必须与服务器验证缓存的新鲜度才能使用
Cache-Control: no-store，不会产生任何缓存


### F5，ctrl + F5, 地址栏刷新对缓存的处理
地址栏刷新相当于第一次请求，会先判断有没有强缓存，再判断有没有协商缓存;页面链接跳转道理相同;前进后退也相同。

F5刷新会跳过强缓存，判断协商缓存。

ctrl + F5  直接去服务端拉最新的资源。

### menory cache 和 disk cache
不同浏览器采取不同的策略
menory cache 小图标 或者文件比较小，常用的脚本(jquery) - 关闭浏览器失效
disk cache   不常用，文件比较大 

### Last-Modified和Etag两者的区别
HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：
1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET。
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。它是md5

Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。



### post请求不能缓存
post请求不能缓存


### 
