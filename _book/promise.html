<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>promise规范</title>
</head>

<body>
  <script>
    // 内部三个状态
    const PENDING = 'PENDING'
    const FULLFILLED = 'FULLFILLED'
    const REJECTED = 'REJECTED'

    class MyPromise {
      constructor(fn) {
        // 处理结果的返回值
        this.value = undefined;
        // then执行fullfill方法合集
        this.resolvedCallbacks = [];
        // then执行reject方法合集
        this.rejectedCallbacks = []
        // 初始为pending，等待状态
        this.state = PENDING;
        const resolve = value => {
          // setTimout模拟异步行为，让同步时then的表现一致
          setTimeout(() => {
            if (this.state === PENDING) {
              this.value = value;
              this.state = FULLFILLED;
              this.resolvedCallbacks.map(r => r(this.value))
            }
          });
        }
        const reject = err => {
          setTimeout(() => {
            if (this.state === PENDING) {
              this.value = err;
              this.state = REJECTED;
              this.rejectedCallbacks.map(r => r(this.value))
            }
          });
        }
        try {
          fn(resolve, reject);
        } catch (error) {
          reject(error)          
        }
      }
      // 静态方法all的实现
      static all(promiseArray) {
        return new MyPromise((resolve, reject) => {
          let successCount = 0;
          let arr = []
          for (let i = 0; i < promiseArray.length; i++) {
            promiseArray[i].then(data => {
              successCount++;
              arr.push(data)
              if (successCount === promiseArray.length) {
                resolve(arr)
              }
            }, err => {
              reject(err)
            })
          }
        })
      }
      then(onFullfilled = val => val, onRejected = err => {
        throw new Error(err)
      }) {
        let promise2;
        if (this.state === FULLFILLED) {
          promise2 = new MyPromise((resolve, reject) => {
            let result = onFullfilled(this.value);
            promiseResolutionProcedure(result, resolve, reject, promise2);
          });
        }

        // 处理已经完成的promise
        if (this.state === REJECTED) {
          promise2 = new MyPromise((resolve, reject) => {
            let result = onRejected(this.value);
            promiseResolutionProcedure(result, resolve, reject, promise2);
          });
        }
        if (this.state === PENDING) {
          // then 返回一个新的promise
          promise2 = new MyPromise((resolve, reject) => {
            this.resolvedCallbacks.push(() => {
              // 除了执行fn外，还需要将结果resolve出去
              let result = onFullfilled(this.value)

              promiseResolutionProcedure(result, resolve, reject, promise2);
            })
            this.rejectedCallbacks.push(() => {
              // 除了执行fn外，还需要将结果resolve出去
              let result = onRejected(this.value)

              promiseResolutionProcedure(result, resolve, reject, promise2);
            })
          })
          return promise2
        }
      }
      catch (onRejected) {
        return this.then(null, onRejected)
      }
    }

    function promiseResolutionProcedure(result, resolve, reject, originPromise) {
      if (originPromise === result) {
        throw new Error("循环引用 promise");
      }
      if (result instanceof MyPromise) {
        if (result.state === PENDING) {
          result.then(resolve, reject);
        } else {
          result.state === FULLFILLED && resolve(result.value);
          result.state === REJECTED && reject(result.value);
        }
      }
      if ((typeof result === "object" || typeof result === "function") && result !== null) {
        if (typeof result.then === "function") {
          result.then(resolve, reject);
        } else {
          resolve(result);
        }
      } else {
        resolve(result);
      }
    }
  </script>
  <script>
    MyPromise.all([
      new MyPromise(resolve => {
        resolve(1);
      }),
      new MyPromise(resolve => {
        resolve(2);
      })
    ]).then(dataList => {
      console.log(dataList);
    });
  </script>
</body>

</html>