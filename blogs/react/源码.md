### this.setState是异步还是同步的
答：需要看setState的调用时机。核心在于调度核心scheduleWork中，如果是批处理，则会合并执行，如果是非批处理，则会立即执行。
生命周期：isBatchUpdate = true     异步
事件回调中：isBatchUpdate = true   异步
原生事件： isBatchUpdate = false   同步
setTimeout：isBatchUpdate = false  同步
isBatchUpdate为true时，通过try finally将多个处理直接返回，最终在finally中统一处理，所以看起来是异步，本质上还是同步代码，并没有放到宏任务中处理。


### 任务调度优先级
最高优先级 ImmediatePriority - 不定：render ReactDOM.render  commitRoot
用户操作   UserBlockPriority 
常规优先级 NormalPriority
低优先级   LowPriority


### 题目
题目： 

```
<father>
   <child1>
      <child3></child3>
   </child1>
   <child2><child2/>
</father>

```
getSnapshotBeforeUpdate，didmount什么顺序执行？

child3   getSnapshotBeforeUpdate
child1   getSnapshotBeforeUpdate
child2   getSnapshotBeforeUpdate
father   getSnapshotBeforeUpdate


child3   didmount
child1   didmount
child2   didmount
father   didmount

原因：
1. 组件的遍历是深度优先遍历，所以从子到父
2. commit阶段会执行三个while循环，每个while都是深度遍历，会执行完所有组件的生命周期，例如getSnapshotBeforeUpdat在第一个while中，didMount在第三个while中，第二个while是真正的渲染


### useEffect(fn, []) 和 componentDidMount 有什么差异？
useEffect 会捕获 props 和 state。所以即便在回调函数里，你拿到的还是初始的 props 和 state。如果想得到“最新”的值，可以使用 ref。



### react hook避免重复渲染的优化
React.memo + useCallback

react.memo类似于class 中的shouldComponentUpdate或者pureComponent

但是react.memo是浅比较，深比较可以选择Immer.js或者Immutable




