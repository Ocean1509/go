### V8回收机制
Node使用Javascript在服务端操作大内存对象受到一定的限制(堆区), 64位操作系统下约为1.4GB, 栈区32位操作系统是0.7G,新生代64位是32M，32位是16M

(读超过1.4G/0.7G)的文件是会报错

V8中内存分为新生代和老生代。新生代为存活时间较短对象，老生代中为存活时间较长的对象。

新生代机制是基于scanvenge算法进行垃圾回收，它将内存(32M/16M)一分为二，两个空间一个被使用，称为From，一个是空闲，称为To。当开始进行垃圾回收时，scanvege会扫描From空间存活的对象，移动到To空间，释放From空间的对象，随后交换From和To空间的位置，这就完成了一次新生代的垃圾回收。当再次扫描新生代进行垃圾回收时，发现对象被回收过则直接将对象转移到老生代空间中，或者当To空间使用超过了25%。新生代生命周期较短。新生代开始执行垃圾回收的时机是From空间占用满的时候(32M/16M)

主GC -> 老生代
副GC -> scanvenge负责新生代

老生代是基于标记清除和标记压缩机制(Mark-Sweep, Mark-compact)。在这个阶段，会遍历堆中的对象，然后标记活的对象，标记完后销毁没有被标记的对象，这就是标记清除，但是在标记大内存是，可能需要几百毫秒才能完成一次标记，所以现在一般使用增量标记。当大量标记清除造成堆中出现大量碎片时，会进行标记压缩算法。

老生代开启GC的时机
    例如： 函数执行栈调用完毕，weakmap会立马GC，内存过大
闭包会在gc阶段回收。

V8怎么执行标记的: 三色标记法，从gc跟节点开始，广度优先遍历，黑色表示这个节点被GC Root引用，白色代表这个节点没有被引用，灰色代表新产生的节点。


主进程如果停下来GC，会造成卡顿，所以垃圾回收器会使用多个辅助线程来执行垃圾回收。

### 命令
Process.memeryUsage
rss： 所有内存使用包括堆内存和栈区
heapTotal: 堆区占用内存 
heapUsed:已使用到的堆部分
external：V8引擎C++对象占用