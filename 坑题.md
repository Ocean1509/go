```
let a = {n: 1}
let b = a;
a.x = a = {n: 2}
console.log(a.x) // undefined
console.log(b.x) // { n: 2 }
```
解析：

点的优先级高于等号，等号执行是从右往左

首先执行a.x，此时a = b = { n: 1, x: undefined }
接着执行 a = { n: 2 },此时a指向变了，而b还是没变。
最后执行a.x = a
所以 a = { n: 2 } b = { n: 1, x: { n: 2 }}




```
var test = [0, 1]
test[10] = 10

var newT = test.filter(v => v === undefined)

newT // []
```

解析：
filter迭代数组时，首先检查这个索引值是不是数组的一个属性
0 in ary; => true
3 in ary; => false
10 in ary; => true

也就是说 从 3 - 9 都是没有初始化的'坑'!, 这些索引并不存在与数组中. 在 array 的函数调用的时候是会跳过这些'坑'的。

